## 除法总结
### 话题1--真假除法
除法同样存在 4 种候选方式的问题：
```scala
val number1 = ... // 被除数
lazy val number2s = ... // 除数正数部分
lazy val number2t = ... // 除数零部分
number1.method1(number2s) // 方式1
number1.method1(number2t) // 方式2
number2s.method2(number1) // 方式3
number2t.method2(number1) // 方式4
```
而除法的筛选则依赖于乘法。

给定一个被除数和除数，使用一种方式得出它们的商。把商和除数转译成相同大小的被乘数和乘数，已知被乘数和乘数的积是唯一的。如果这个积的大小与被除数相等，我们说这次运算是可以还原的。

给定一个充分大的数据集，被除数是 Number1S（大于 0），除数是 Number2S（大于 0）。如果对于这些输入，有一些方式存在还原可能，那这些方式就被选中为除法的表现方式。

通过统计可以知道，有两种方式存在还原可能，并且这两种方式的还原次数对于任意数据集都是一样的。当运算无法被这两种方式还原时，一种方式的结果总是另一种方式的后继。

对应现代的除法可知，可以还原的情况是整除。无法还原的时候，商较大的一种方式是上舍法，商较小的一种方式是下舍法。