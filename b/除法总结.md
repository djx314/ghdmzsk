## 除法总结
### 话题1--真假除法
除法也有同样的问题：
```scala
val number1 = ... // 被除数
lazy val number2s = ... // 除数正数部分
lazy val number2t = ... // 除数零部分
number1.method1(number2s) // 方式1
number1.method1(number2t) // 方式2
number2s.method2(number1) // 方式3
number2t.method2(number1) // 方式4
```
按照规律，应该也有两种方式能够成为除法的表现方式。这里的筛选依赖于乘法的结果。

假定一种方式执行完的商被转译成相同大小的被乘数，这种方式的除数被转译成相同大小的乘数，已知被乘数和乘数的积是唯一的。如果这个积的大小与被除数相等，我们说这次运算在这个方式下是可以还原的。

给定一个充分大的数据集，被除数和除数都是大于 0 的自然数，亦即被除数是 Number1S，除数是 Number2S，如果在这些运算中，有一些方式存在还原可能，那这些方式就被选中为除法的表现方式。

通过统计可以知道，有两种方式被选中了，并且这两种方式的还原次数对于任意数据集都是一样的，当运算没法被这两种方式还原时，一种方式的结果总是另一种方式的后继。对应现代的除法可以得知，可以还原的情况是整除，当不是整除的时候，商较大的一种方式是上舍法，商较小的一种方式是下舍法。