## 除法总结
### 话题1--真假除法
除法同样存在 4 种候选方式需要筛选的问题：
```scala
val number1 = ... // 被除数
lazy val number2s = ... // 除数正数部分
lazy val number2t = ... // 除数零部分
number1.method1(number2s) // 方式1
number1.method1(number2t) // 方式2
number2s.method2(number1) // 方式3
number2t.method2(number1) // 方式4
```
按照规律，应该也有两种方式能够成为除法的表现方式。而除法的筛选依赖于乘法。

给定一个被除数和除数，除数被转译成相同大小的被乘数，使用一种方式得出被除数和除数的商，这个商被转译成相同大小的乘数，已知被乘数和乘数的积是唯一的。如果这个积的大小与被除数相等，我们说这次运算是可以还原的。

给定一个充分大的数据集，被除数和除数都是大于 0 的自然数，亦即被除数是 Number1S，除数是 Number2S。对每一个输入使用 4 种方式求商，如果有一些方式存在还原可能，那这些方式就被选中为除法的表现方式。

通过统计可以知道，有两种方式存在还原可能，并且这两种方式的还原次数对于任意数据集都是一样的，当运算没法被这两种方式还原时，一种方式的结果总是另一种方式的后继。对应现代的除法可知，可以还原的情况是整除，无法还原的时候，商较大的一种方式是上舍法，商较小的一种方式是下舍法。