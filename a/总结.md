## 第一阶运算法则总结
### 话题1--鸡蛋问题
熟习减法之后，我们可以窥视一下一个千古难题的基本思路。这世上究竟是有鸡先还有有蛋先呢？观察减法的一个测试用例：
```scala
val number1 = Number1S(Number1S(Number1S(Number1S(Number1S(Number1T, item01), item02), item03), item04), item05)
val number2 = Number2S(Number2S(Number2T, item06), item07)
val number3 = Number1S(Number1S(Number1S(Number1T, item01), item02), item03)
assert(number2.method2(number1) == number3)
```
在这里，究竟是先有`number1`还是先有`number2`呢？答案是`number1`，那么鸡蛋问题就永远没有答案，因为答案会随着写法改变而改变。但是我换一段代码，换一个问法：
```scala
trait Number1 {
  def method1(number2: Number2, item2: Item): Number1
}
trait Number2 {
  def method2(number1: Number1): Number1
}
```
在这里，是先有`Number1`还是先有`Number2`呢？可以看到，在`Number1`产生的瞬间，`Number2`的需求已经产生了，也就是说必须要有`Number2`，`Number1`才能产生。反之亦然。所以你可以说，它们是同时产生的，其实它们处于一个你中有我，我中有你的状态。这个讨论就有意义了，你可以理解为我们讨论的不是第一只鸡这个个体和第一只蛋这个个体，而是鸡这个类和蛋这个类。当第一只鸡产生的时候，鸡这个类已经出现了。由于鸡要生蛋，蛋这个类也在这一瞬间出现了。

在这个库中，我们会反反复复，从不同层面遇到这一类问题。

### 话题2--平衡现象
在第一阶运算法则中，我们由只有一个运算数有行为，发展到了两个运算数互相作用，由`identity`函数，衍生出两对平衡。·2·22343听过5同样5


# 临时笔记
1. 第一对平衡，零和后继，零出现在减法的函数体，后继出现在加法的函数体。
1. 第二对平衡，对方传过来的 number 和 (tail, head)，这两个通常存在于同一方法内，减法则是把调用方交托给对方，加法则是保持自己调用此函数，把调用方交给对方和保持自己调用这个函数的平衡，是第二对平衡。
1. 第三对平衡，乘法以有后继的函数体的那个类为正数部分，调用方交托给对方的那个类为零部分。除法则以调用方交托给对方的那个类为正数部分，调用方保持自己的类为零部分。
1. 第四对平衡，乘法和除法的`HList`作为主体调用另外一个运算数进行运算，则较快减少，轮需要使用有后继的部分进行运算，如果`HList`是作为被传入参数被另外一个运算数调用进行运算，则较慢减少，则需要使用没有后继的部分进行运算。

### 分析
1. 第一对平衡和第二对平衡中，零和后继的平衡点是数本身，相对于传入参数就是传入参数本身，相对于数内部就是 (tail, head)，这与第二个平衡的主体也是一样的。所以第一个平衡的中介点相对于一个数来说是 (tail, head)，还有对方入参，一般对方入参 ideneity 可以忽略。
1. 第三对平衡和第四对平衡中，都有一个相同的平衡主体，就是零和正数部分。
1. 加法和减法是第一对平衡和第二对平衡均匀分配的结果，各自都加上一个 identity 的函数。
1. 乘法和除法是加减法混合后，去掉 identity 函数的产物，只不过附加了第三对平衡和第四对平衡。
1. (tail, head) 这对平衡主体，零（没有内容）和正数（有内容）部分这对平衡主体，又孕育出第五对平衡
```scala
case class Item()
trait Number1
case class Number1S(tail: Number1, head: Item) extends Number1
case object Number1T extends Number1
```
刚刚好，又回到了法的最开始，加法还未产生，只有数据结构的时候，`HList`。
