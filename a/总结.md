## 第一阶运算法则总结
### 话题1--平衡现象（未校正文字）（暂不需要，这些都会在后续的章节中以代码形式体现）
在加减法中，我们留意这么几段代码段
```scala
def method1(number1: Number1): Number1 = Number1S(tail.method1(number1), head) // 加数正数部分
def method1(number2: Number2, item2: Item): Number1 = number2.method2(tail) // 被减数正数部分
def method2(number1: Number1): Number1 = number1.method1(tail, head) // 减数正数部分
```
大家可以注意到，如果入参是`(tail, head)`的形态，那么，函数体就只会调用自身的`tail`这个属性，反之，如果入参只有对方的`tail`，则函数体会兼具自身的`tail`和`head`。

加法由于使用`tail`调用回自身的函数，所以`head`需要后继(`Number1S`)这个结构消化。减法可以消化`head`，但是会多出一个空的函数体需要实现，使用零(`Number1T`)填充，至于被减数正数部分同时舍弃两个`head`是减法本身的含义使然。

另外，(tail, head) 和 tail 这对平衡主体，跟乘数、除数关联甚大。

# 临时笔记（暂不需要，这些都会在后续的章节中以代码形式体现）
1. 第一对平衡，零和后继，零出现在减法的函数体，后继出现在加法的函数体。
1. 第二对平衡，对方传过来的 number 和 (tail, head)，这两个通常存在于同一方法内，减法则是把调用方交托给对方，加法则是保持自己调用此函数，把调用方交给对方和保持自己调用这个函数的平衡，是第二对平衡。
1. 第三对平衡，乘法以有后继的函数体的那个类为正数部分，调用方交托给对方的那个类为零部分。除法则以调用方交托给对方的那个类为正数部分，调用方保持自己的类为零部分。
1. 第四对平衡，乘法和除法的`HList`作为主体调用另外一个运算数进行运算，则较快减少，轮需要使用有后继的部分进行运算，如果`HList`是作为被传入参数被另外一个运算数调用进行运算，则较慢减少，则需要使用没有后继的部分进行运算。

### 分析
1. 第一对平衡和第二对平衡中，零和后继的平衡点是数本身，相对于传入参数就是传入参数本身，相对于数内部就是 (tail, head)，这与第二个平衡的主体也是一样的。所以第一个平衡的中介点相对于一个数来说是 (tail, head)，还有对方入参，一般对方入参 ideneity 可以忽略。
1. 第三对平衡和第四对平衡中，都有一个相同的平衡主体，就是零和正数部分。
1. 加法和减法是第一对平衡和第二对平衡均匀分配的结果，各自都加上一个 identity 的函数。
1. 乘法和除法是加减法混合后，去掉 identity 函数的产物，只不过附加了第三对平衡和第四对平衡。
1. (tail, head) 这对平衡主体，零（没有内容）和正数（有内容）部分这对平衡主体，又孕育出第五对平衡
```scala
case class Item()
trait Number1
case class Number1S(tail: Number1, head: Item) extends Number1
case object Number1T extends Number1
```
刚刚好，又回到了法的最开始，加法还未产生，只有数据结构的时候，`HList`。
