## 第一阶运算法则总结
### 鸡蛋问题
熟习减法之后，我们可以窥视一下一个千古难题的基本思路。这世上究竟是有鸡先还有有蛋先呢？观察减法的一个测试用例：
```scala
val number1 = Number1S(Number1S(Number1S(Number1S(Number1S(Number1T, item01), item02), item03), item04), item05)
val number2 = Number2S(Number2S(Number2T, item06), item07)
val number3 = Number1S(Number1S(Number1S(Number1T, item01), item02), item03)
assert(number2.method2(number1) == number3)
```
在这里，究竟是先有`number1`还是先有`number2`呢？答案是`number1`，那么鸡蛋问题就永远没有答案，因为答案会随着写法改变而改变。但是我换一段代码，换一个问法：
```scala
trait Number1 {
  def method1(number2: Number2, item2: Item): Number1
}
trait Number2 {
  def method2(number1: Number1): Number1
}
```
在这里，是先有`Number1`还是先有`Number2`呢？可以看到，在`Number1`产生的瞬间，`Number2`的需求已经产生了，也就是说必须要有`Number2`，`Number1`才能产生。反之亦然。所以你可以说，它们是同时产生的，其实它们处于一个你中有我，我中有你的状态。这个讨论就有意义了，你可以理解为我们讨论的不是第一只鸡这个个体和第一只蛋这个个体，而是鸡这个类和蛋这个类。当第一只鸡产生的时候，鸡这个类已经出现了。由于鸡要生蛋，蛋这个类也在这一瞬间出现了。

在这个库中，我们会反反复复，从不同层面遇到这一类问题。

### 平衡现象


在第一阶运算法则中，我们由只有一个运算数有行为，发展到了两个运算数互相作用，由`identity`函数，衍生出两对平衡。


#临时笔记
